#version 450
#extension GL_GOOGLE_include_directive : require

// https://www.reddit.com/r/vulkan/comments/cabask/set_localsize_dynamically/
layout(local_size_x = 16, local_size_y = 16) in;
// layout(local_size_x = 32, local_size_y = 32) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D result_image;


#define PER_FRAME_SET 1

#define PER_FRAME_VOXEL_OCTREE_DATA 0
#define PER_FRAME_VOXEL_OCTREE_INFO 1
#define PER_FRAME_CAMERA 2
#define PER_FRAME_LIGHTING 3

#define DRAW_MODE_LIT 0
#define DRAW_MODE_ALBEDO 1
#define DRAW_MODE_LITS 2

#define DRAW_METHOD_CHUNK_TREE 0


layout(set = PER_FRAME_SET, binding = PER_FRAME_CAMERA) uniform Camera
{
	mat4 view;
	vec4 max_distance_X_field_of_view_Y;
	vec4 world_size;
	
	ivec4 draw_options; // x: DRAW_MODE_, y: DRAW_METHOD_, z: draw bounds
	vec4 debug_options;
} camera;

layout(set = PER_FRAME_SET, binding = PER_FRAME_LIGHTING) uniform Lighting
{
	vec4 direct_direction;
	vec4 direct_color;
	vec4 ambient_color;
} lighting;

float get_max_distance()
{
	return camera.max_distance_X_field_of_view_Y.x;
}	

float get_field_of_view()
{
	return camera.max_distance_X_field_of_view_Y.y;
}

float get_smoothness()
{
	return clamp(camera.debug_options.x, 0, 1);
}

float get_specular_strength()
{
	return clamp(camera.debug_options.w, 0, 1);
}

float get_bounce_ray_length()
{
	return camera.debug_options.y;
}

float get_normal_offset()
{
	return camera.debug_options.z;
}

vec3 get_world_size()
{
	return vec3(camera.world_size.x, camera.world_size.x, camera.world_size.x);
}

int get_draw_mode()
{
	return camera.draw_options.x;
}

int get_draw_method()
{
	return camera.draw_options.y;
}

#include "raycast.glsl"
#include "chunktree.glsl"

Ray get_camera_ray()
{
	vec2 resolution = vec2(imageSize(result_image));
	vec2 uv = gl_GlobalInvocationID.xy / resolution;
	uv = uv * 2 - 1;
	uv.x *= resolution.x / resolution.y;

	Ray ray;
	ray.origin = (camera.view * vec4(0,0,0,1)).xyz;
	
	ray.direction = normalize(vec3(uv, get_field_of_view()));
	ray.direction = (camera.view * vec4(ray.direction, 0)).xyz;

	ray.inverse_direction = 1.0 / ray.direction;

	// ray.sign = ivec3(mix(sign(ray.direction), vec3(0,0,0), vec3(1,1,1)));

	return ray;
}

bool draw_bounds(Ray camera_ray)
{
	if (camera.draw_options.z == 0)
	{
		return false;
	}


	const float width = 0.1;

	const vec3 bound_mins [12] = vec3[]
	(
		vec3(0,	0,0),
		vec3(0, get_world_size().y - width, 0),
		vec3(0, 0, get_world_size().z - width),
		vec3(0, get_world_size().y - width, get_world_size().z - width),

		vec3(0,	0,0),
		vec3(get_world_size().x - width, 0, 0),
		vec3(0, 0, get_world_size().z - width),
		vec3(get_world_size().x - width, 0, get_world_size().z - width),

		vec3(0,	0,0),
		vec3(get_world_size().x - width, 0, 0),
		vec3(0, get_world_size().y - width, 0),
		vec3(get_world_size().x - width, get_world_size().y - width, 0)
	);

	const vec3 bound_maxs[12] = vec3[]
	(
		vec3(get_world_size().x, width, width),
		vec3(get_world_size().x, get_world_size().y, width),
		vec3(get_world_size().x, width, get_world_size().z),
		vec3(get_world_size().x, get_world_size().y, get_world_size().z),

		vec3(width, get_world_size().y, width),
		vec3(get_world_size().x, get_world_size().y, width),
		vec3(width, get_world_size().y, get_world_size().z),
		vec3(get_world_size().x, get_world_size().y, get_world_size().z),

		vec3(width, width, get_world_size().z),
		vec3(get_world_size().x, width, get_world_size().z),
		vec3(width, get_world_size().y, get_world_size().z),
		vec3(get_world_size().x, get_world_size().y, get_world_size().z)
	);

	float ignored_out_distance;
	if (
		raycast(camera_ray, bound_mins[0], bound_maxs[0], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[1], bound_maxs[1], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[2], bound_maxs[2], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[3], bound_maxs[3], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[4], bound_maxs[4], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[5], bound_maxs[5], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[6], bound_maxs[6], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[7], bound_maxs[7], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[8], bound_maxs[8], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[9], bound_maxs[9], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[10], bound_maxs[10], 100, ignored_out_distance) ||
		raycast(camera_ray, bound_mins[11], bound_maxs[11], 100, ignored_out_distance)
	)
	{
		return true;
	}

	return false;
}

void main()
{

	Ray camera_ray = get_camera_ray();

	vec3 background_color;
	{
		vec3 dir = camera_ray.direction;


		background_color = mix(dir, vec3(1,1,1), 0.7);
		// float avg_value = (dir.x + dir.y + dir.z) / 3 / 2 + 0.5;
		// // float avg_value = max(max(camera_ray.direction.x, camera_ray.direction.y), camera_ray.direction.z) / 2 + 0.5;
		// avg_value = smoothstep(0,1, avg_value);
		// avg_value = avg_value * 0.6 + 0.4;
		// background_color = mix(background_color, vec3(avg_value, avg_value, avg_value), 0.6);
	}
	vec3 color = background_color;
	// color = vec3(0,0,0);


	vec4 ray_result_color = traverse_chunktree(camera_ray, get_max_distance());

	float src_alpha 			= clamp(ray_result_color.a, 0, 1);
	float one_minus_src_alpha 	= 1.0 - src_alpha;
	color = src_alpha * ray_result_color.rgb + one_minus_src_alpha * color;

	vec3 debug_color = vec3(0, 0.8, 0.8);

	if (draw_bounds(camera_ray))
	{
		color = debug_color;
	}

	vec4 result = vec4(color, 1);    

	ivec2 store_position = ivec2(gl_GlobalInvocationID.xy);
	store_position.y = imageSize(result_image).y - store_position.y;
	imageStore(result_image, store_position, result);
}

